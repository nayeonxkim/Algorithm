'''
32888 2번 교환하여 가장 큰 수.

1. for문 3~4개 써서 교환
- 1회차 교환에서 가장 큰 수로 2회차 교환
-> 2회차 교환에서 가장 큰 수가 정답
=> 1회차 교환에서 가장 큰 수에서 2회차 교환을 진행

BUT 이게 꼭 가장 큰 수 X (15개 中 14개 정답)

32888 2번 교환했을 때 가장 큰 수는 88832
근데 위 방법대로 하면
1회차 교환 후 최대값 : '8'288'3'
82883에서 한번 더 교환 후 최대값 : 8'8'8'2'3

-> 1회차 교환한 모든 경우의 수에서 2회차 교환을 진행해야함.
-> 2회차 교환까지 마친 모든 경우의 수에서 최대값을 찾아야함

---

2. 재귀

1회차 교환
((2회차 교환 호출)) --> 이때 최대값 비교
1회차 교환 취소
- 해당 1회차 경우에서 2회차 교환 다끝나면,
원래대로 돌아오고 다른 1회차 경우에서 다시 2회차 교환)
-> 이 구조 반복

(1) 교환 회차별로 나누어서, 교환 후의 카드 상태를 저장한다.
123 일 때,
0회차 : 123
1회차 : 213, 321, 132
2회차 : 123, 312, ...
=> visited =[[], [], []]

(2) 카드 교환
<<옆 카드랑 교환: 1과 2, 3>>  for문 2개 사용
0회차 교환
((1회차 교환))
0회차 교환 취소
-> 0회차 교환의 다른 경우로 넘어감

(3) 교환 후, 현재 카드 상태를 해당 회차 리스트에 추가한다.
visited[[123], [], []]

(4) 종료조건
카드 교환을 마쳤는데, 해당 교환 회차에 같은 카드 상태가 이미 있다면 ?
예) 1회차 교환 후, 132가 되었다. 근데 이미 1회차 교환 후 132가 되는 경우를 visited에 저장해둠.
-> 2회차 교환이 완전히 똑같다. 그래서 2회차 교환 함수를 또 호출할 필요가 없다.
=> visited[현재교환회차]에 해당 카드상태가 이미 있으면 함수를 종료한다.

(5) 재귀 호출 끝 (마지막 가지)
마지막 교환 회차에서 최대값을 업데이트한다.

'''

import sys
sys.stdin = open('input.txt')

# k = 교환회차
def change(k):

    global max_num

    # num = ['1', '2', '3'] -> val = 123
    val = int(''.join(num))

    ### (4) 종료조건 ###
    if val in visited[k]:
        return

    ### (3) 교환 후, 현재 카드 상태를 해당 회차 리스트에 추가한다. ###
    visited[k].append(val)

    ### (5) 재귀호출 끝 ###
    if k == N:
        max_num = max(max_num, val)

    # 아직 교환 다 안끝났으면 교환해
    ### (2) 카드 교환 ###
    else:
        for i in range(len(num)-1):
            for j in range(i+1, len(num)):
                num[i], num[j] = num[j], num[i]
                # 0회 교환 -> 1회 교환 -> 2회 교환 -> ...
                # 앞 회차에서 교환된 상태로 재귀 호출됨.
                change(k+1)
                # 원위치
                num[i], num[j] = num[j], num[i]


T = int(input())
for tc in range(1, T+1):
    temp, N = input().split()

    # N = 1, num = ['1', '2', '3']
    N = int(N)
    num = list(temp)

    ### (1) 교환 회차별로 나누어서, 교환 후의 카드 상태를 저장한다. ###
    # 최대 10번 교환
    # : 원래 상태(0번 교환) ~ 10번 교환한 카드 상태를 각각 리스트에 저장한다.
    # 각 인덱스 = 현재 교환 회차 (0번 교환한 카드의 상태 = visited[0]에 저장)
    visited = [[] for _ in range(11)]
    max_num = 0

    # 0회부터 시작
    change(0)
    print(f'#{tc} {max_num}')

